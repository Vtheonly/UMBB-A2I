


### Objective

The Nagao filter is an **adaptive, edge-preserving smoothing filter**. Its main goal is to reduce noise in homogeneous areas while maintaining edges and fine details, unlike traditional mean or median filters which apply uniform smoothing everywhere.

---

## 1. Why an Adaptive Filter?

- **Mean (Low-Pass) Filter:** Smooths the image but blurs edges and corners.
    
- **Median Filter:** Better at preserving edges but can still degrade textures or rounded features.
    
- **Nagao Filter:** Adaptive—it analyzes local structure and selectively smooths only homogeneous regions, leaving edges intact.
    

> This makes it one of the first "intelligent" filters encountered in image processing.

---

## 2. The Algorithm – Step by Step

The Nagao filter works pixel by pixel, using a **5×5 neighborhood** and splitting it into **9 sub-regions**.

### Step 1: Analysis Window

Define a 5×5 window around the central pixel:

```
P11 P12 P13 P14 P15
P21 P22 P23 P24 P25
P31 P32 P33 P34 P35
P41 P42 P43 P44 P45
P51 P52 P53 P54 P55
```

### Step 2: Sub-Regions

Divide the window into 9 overlapping 3×3 sub-regions:

1. Top-left
    
2. Top-center
    
3. Top-right
    
4. Middle-left
    
5. Center (central 3×3)
    
6. Middle-right
    
7. Bottom-left
    
8. Bottom-center
    
9. Bottom-right
    

Each sub-region captures different spatial patterns around the central pixel.

### Step 3: Compute Variance

For each sub-region, calculate variance:

- **Low variance:** Homogeneous, flat region → good for smoothing
    
- **High variance:** Edge, texture, or noise → avoid averaging across it
    

[  
\text{Variance} = \frac{1}{N} \sum_{i=1}^N (x_i - \mu)^2  
]

Where (x_i) are pixel values and (\mu) is the mean.

### Step 4: Select Best Sub-Region

Choose the sub-region with the **minimum variance**.

- Ensures smoothing occurs only along homogeneous regions.
    
- Protects edges from being blurred.
    

### Step 5: Compute Mean

Calculate the **mean** of the pixels in the selected sub-region.

### Step 6: Update Pixel

Replace the central pixel with this mean value. Repeat for all pixels in the image.

---

## 3. Visual Representation – LaTeX Diagram

A 5×5 window with 9 sub-regions, each highlighted in a different color:
$$
\documentclass{standalone}
\usepackage{tikz}
\usetikzlibrary{matrix,positioning}

\begin{document}

\begin{tikzpicture}

\matrix[matrix of nodes,nodes={draw, minimum size=8mm, anchor=center},column sep=-\pgflinewidth, row sep=-\pgflinewidth] (m) {
  P_{11} & P_{12} & P_{13} & P_{14} & P_{15} \\
  P_{21} & P_{22} & P_{23} & P_{24} & P_{25} \\
  P_{31} & P_{32} & P_{33} & P_{34} & P_{35} \\
  P_{41} & P_{42} & P_{43} & P_{44} & P_{45} \\
  P_{51} & P_{52} & P_{53} & P_{54} & P_{55} \\
};

% Draw colored sub-regions
\begin{scope}[on background layer]
\fill[red!30] (m-2-2.north west) rectangle (m-4-4.south east);   % center
\fill[blue!30] (m-1-1.north west) rectangle (m-3-3.south east);  % top-left
\fill[green!30] (m-1-2.north west) rectangle (m-3-4.south east); % top
\fill[yellow!30] (m-1-3.north west) rectangle (m-3-5.south east);% top-right
\fill[cyan!30] (m-2-1.north west) rectangle (m-4-3.south east);   % left
\fill[magenta!30] (m-2-3.north west) rectangle (m-4-5.south east); % right
\fill[orange!30] (m-3-1.north west) rectangle (m-5-3.south east);  % bottom-left
\fill[purple!30] (m-3-2.north west) rectangle (m-5-4.south east);  % bottom
\fill[brown!30] (m-3-3.north west) rectangle (m-5-5.south east);   % bottom-right
\end{scope}

\end{tikzpicture}
\end{document}
$$

- Each color corresponds to a sub-region.
    
- The filter calculates variance for all, selects the minimum, and updates the central pixel.
    

---

## 4. Python Implementation

```python
import numpy as np
import cv2

def nagao_filter(image, kernel_size=5):
    """
    Applies the Nagao adaptive filter to a grayscale image.

    Args:
        image (np.ndarray): Input grayscale image.
        kernel_size (int): Size of the main analysis window (odd integer).

    Returns:
        np.ndarray: Filtered image.
    """
    if kernel_size % 2 == 0:
        kernel_size += 1

    height, width = image.shape
    output_image = np.zeros_like(image, dtype=np.uint8)
    k = kernel_size // 2

    # Process each pixel
    for i in range(k, height - k):
        for j in range(k, width - k):
            neighborhood = image[i-k:i+k+1, j-k:j+k+1]
            
            sub_regions = [
                neighborhood[0:3, 0:3],  # Top-left
                neighborhood[0:3, 1:4],  # Top-center
                neighborhood[0:3, 2:5],  # Top-right
                neighborhood[1:4, 0:3],  # Middle-left
                neighborhood[1:4, 1:4],  # Center
                neighborhood[1:4, 2:5],  # Middle-right
                neighborhood[2:5, 0:3],  # Bottom-left
                neighborhood[2:5, 1:4],  # Bottom-center
                neighborhood[2:5, 2:5]   # Bottom-right
            ]
            
            variances = [np.var(region) for region in sub_regions]
            best_region = sub_regions[np.argmin(variances)]
            output_image[i, j] = np.uint8(np.mean(best_region))

    return output_image

# Usage
img = cv2.imread('noisy_image.png', cv2.IMREAD_GRAYSCALE)
filtered = nagao_filter(img)
cv2.imwrite('nagao_filtered.png', filtered)
```

---

## 5. Key Points

- **Adaptive Smoothing:** Reduces noise in flat regions, preserves edges.
    
- **Variance-based Decision:** Chooses sub-region intelligently.
    
- **Neighborhood Size Matters:** Larger window → more smoothing, slower computation.
    
- **Applications:** Medical imaging, OCR preprocessing, denoising images with fine textures.
    
