---
title: "2. NumPy Array Operations"
---

The lab exercises use several NumPy functions to create noise, manipulate image data, and calculate statistics. These functions are highly optimized and much faster than manual `for` loops.

#Keywords
#NumPy #ArrayOperations #clip #random #mean

---

## Array Creation & Manipulation

### `np.copy()`
Creates a completely independent copy of an array. This is essential for non-destructive editing.

| Parameter | Type | Description |
| :--- | :--- | :--- |
| `a` | `ndarray` | The array to be copied. |

**Why it's important:**
- `new_img = old_img` **DOES NOT** create a copy. Both variables point to the same data.
- `new_img = np.copy(old_img)` creates a true duplicate. Changes to `new_img` will not affect `old_img`.

```python
# From sp_noise in Lab_solution.py
output = np.copy(image) # Ensures the original image is not modified
```

### `np.random.normal()`
Creates an array of a given shape and fills it with random samples from a normal (Gaussian) distribution. This is used in `exercise_1` to create Gaussian noise.

| Parameter | Type | Description |
| :--- | :--- | :--- |
| `loc` | `float` | The mean ("center") of the distribution. |
| `scale` | `float` | The standard deviation of the distribution. |
| `size` | `tuple` | The shape of the output array (e.g., the image's shape). |

```python
# Create noise with the same dimensions as the input image 'im1'
gaussian_noise = np.random.normal(mean, sigma, im1.shape)
# Add the noise to the image (element-wise addition)
im2 = im1 + gaussian_noise 
```

### `np.clip()`
Forces the values in an array to be within a specified range `[min, max]`. This is critical for bringing pixel values back into the valid `[0, 255]` range after operations like adding noise.

| Parameter | Type | Description |
| :--- | :--- | :--- |
| `a` | `ndarray` | The input array. |
| `a_min` | `number` | The minimum value. Anything less becomes this. |
| `a_max` | `number` | The maximum value. Anything more becomes this. |

```python
# From exercise_1, after adding float noise to a uint8 image
# 1. Clip values to the valid 0-255 range
# 2. Convert the array's data type back to uint8
im2 = np.clip(im2, 0, 255).astype(np.uint8)
```

### `np.zeros_like()`
Creates a new array with the same shape and data type as a given array, but filled with zeros.

| Parameter | Type | Description |
| :--- | :--- | :--- |
| `a` | `ndarray` | The array to mimic the shape and type of. |

```python
# Creates a black image with the same dimensions as 'image'
output_img = np.zeros_like(image)
```

---

## Statistical Functions

### `np.mean()`
Calculates the arithmetic mean of all the elements in an array.

```python
# Used in calculate_psnr to find the Mean Squared Error
mse = np.mean((img1.astype(np.float64) - img2.astype(np.float64)) ** 2)
```

### `np.var()`
Calculates the variance of the elements in an array. Variance measures how spread out the data is. In the `nagao_filter`, it's used to find the sub-region with the smoothest texture (lowest variance).

### `np.unique()`
Finds and returns the sorted unique elements of an array. In `exercise_4`, it's used to count the number of cells found by the watershed algorithm, where each cell has been assigned a unique integer label.